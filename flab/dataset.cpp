#include <map>
#include <vector>
#include <fstream>
#include <random>

#include <pugixml.hpp>
#include <aux-cvt.h>

#include "dataset.h"

Dataset::~Dataset()
{
    stop(true);
}

static void fillBoxes(const pugi::xml_node &image, std::vector<Dataset::Image::Box> &boxes)
{
    for (pugi::xml_node box : image.children("box"))
    {
        Dataset::Image::Box b;
        b.top = box.attribute("top").as_int();
        b.left = box.attribute("left").as_int();
        b.width = box.attribute("width").as_int();
        b.height = box.attribute("height").as_int();
        for (pugi::xml_node part : box.children("part"))
        {
            Dataset::Image::Box::Part p;
            p.x = part.attribute("x").as_int();
            p.y = part.attribute("y").as_int();
            b.parts.push_back(p);
        }
        boxes.push_back(b);
    }
}

static std::vector<Dataset::Image::Box> loadBoxes(const std::wstring &file)
{
    std::vector<Dataset::Image::Box> boxes;
    pugi::xml_document doc;
    if (doc.load_file(file.c_str()))
    {
        auto image = doc.child("dataset").child("images").child("image");
        if (image)
            fillBoxes(image, boxes);
    }
    return boxes;
}

static bool saveImages(std::wstring path, const std::vector<std::shared_ptr<Dataset::Image>> &images)
{
    pugi::xml_document doc;
    pugi::xml_node decl = doc.prepend_child(pugi::node_declaration);
    decl.append_attribute("version").set_value("1.0");
    decl.append_attribute("encoding").set_value("UTF-8");
    auto d = doc.append_child("dataset");
    d.append_child("name").text().set("Generated by FeatureLab");
    d.append_child("comment").text().set("Check more detail on https://github.com/AlexLightTak/FeatureLab");
    auto imgs = d.append_child("images");
    for (auto image : images)
    {
        auto img = imgs.append_child("image");
        img.append_attribute("file").set_value(image->name.c_str());
        for (auto const &box : image->boxes)
        {
            auto b = img.append_child("box");
            b.append_attribute("top").set_value(box.top);
            b.append_attribute("left").set_value(box.left);
            b.append_attribute("width").set_value(box.width);
            b.append_attribute("height").set_value(box.height);
            for (size_t i = 0; i < box.parts.size(); i++)
            {
                auto p = b.append_child("part");
                p.append_attribute("name").set_value(std::format("{:02d}", i).c_str());
                p.append_attribute("x").set_value(box.parts[i].x);
                p.append_attribute("y").set_value(box.parts[i].y);
            }
        }
    }
    return doc.save_file(path.c_str(), "\t", pugi::format_default, pugi::encoding_utf8);
}

static std::wstring xmlFileNameFromImageFileName(const std::wstring &file)
{
    auto ext = std::filesystem::path(file).extension().wstring();
    return file.substr(0, file.size() - ext.size()) + L".xml";
}

bool Dataset::save(std::shared_ptr<Image> image)
{
    return saveImages(xmlFileNameFromImageFileName(image->file).c_str(), {image});
}

bool Dataset::load(std::wstring path, std::function<void(LoadResult)> cb)
{
    auto fn = [this, cb]()
    {
        busy = true;
        try
        {
            {
                LoadResult result;
                result.type = LoadResult::TypeStarted;
                cb(result);
            }

            std::vector<std::wstring> exts({L".jpg", L".png"});
            for (const auto &entry : std::filesystem::recursive_directory_iterator(current))
            {
                if (!active)
                    break;

                if (!entry.is_directory())
                {
                    auto ext = entry.path().extension().wstring();
                    if (std::any_of(exts.begin(), exts.end(), [ext](const std::wstring &v)
                                    { return v == ext; }))
                    {
                        auto file = entry.path().wstring();
                        LoadResult result;
                        result.type = LoadResult::TypeImage;
                        result.image = std::make_shared<Image>();
                        result.image->name = aux::w2utf(file.substr(current.wstring().size() + 1));
                        result.image->file = file;
                        result.image->boxes = loadBoxes(xmlFileNameFromImageFileName(file));
                        {
                            Lock l(mtx);
                            result.image->index = int(images.size());
                            images.push_back(result.image);
                        }
                        cb(result);
                    }
                }
            }

            {
                LoadResult result;
                result.type = LoadResult::TypeSuccess;
                cb(result);
            }
        }
        catch (const std::exception &e)
        {
            LoadResult result;
            result.type = LoadResult::TypeError;
            result.error = e.what();
            cb(result);
        }
        busy = false;
    };
    if (busy)
        return false;
    stop(true);
    active = true;
    {
        Lock l(mtx);
        images.clear();
    }
    current = path;
    worker = std::make_shared<std::thread>(fn);
    while (!busy)
        std::this_thread::sleep_for(std::chrono::microseconds(1));
    return true;
}

Dataset::GetResult Dataset::get(int start, int count)
{
    Lock l(mtx);
    Dataset::GetResult result;
    int sz = int(images.size()), begin = 0, end = 0;
    if (count < 0)
    {
        begin = min(max(start + count, 0), sz);
        end = min(max(start, 0), sz);
    }
    else
    {
        begin = min(max(start, 0), sz);
        end = min(max(start + count, 0), sz);
    }
    result.images.assign(images.begin() + begin, images.begin() + end);
    result.morebefore = begin;
    result.moreafter = sz - end;
    return result;
}

int Dataset::count()
{
    Lock l(mtx);
    return int(images.size());
}

bool Dataset::stop(bool wait)
{
    active = false;
    if (worker)
    {
        if (worker->joinable())
        {
            if (wait || !busy)
            {
                worker->join();
                worker.reset();
            }
            else
                return false;
        }
        else
            worker.reset();
    }
    return true;
}

bool Dataset::remove(std::wstring path)
{
    std::error_code ec;
    std::filesystem::remove(xmlFileNameFromImageFileName(path), ec);
    if (std::filesystem::remove(path, ec))
    {
        Lock l(mtx);
        images.erase(std::remove_if(images.begin(), images.end(),
                                    [path](std::shared_ptr<Image> image)
                                    { return image->file == path; }));
        return true;
    }
    return false;
}

bool Dataset::exportXml(std::wstring path)
{
    std::vector<std::shared_ptr<Image>> v;
    {
        Lock l(mtx);
        v.assign(images.begin(), images.end());
    }
    std::random_device rd;
    std::mt19937 g(rd());
    std::shuffle(v.begin(), v.end(), g);
    auto it = v.begin() + v.size() / 10;
    std::filesystem::path p(path);
    auto p0 = p.parent_path() / p.stem();
    return saveImages(path, v) &&
           saveImages(p0.wstring() + L"_train" + p.extension().wstring(), {it, v.end()}) &&
           saveImages(p0.wstring() + L"_test" + p.extension().wstring(), {v.begin(), it});
}

bool Dataset::importFromiBUG(std::wstring path, std::function<void(LoadResult)> cb)
{
    auto fn = [this, path, cb]()
    {
        busy = true;
        try
        {
            {
                LoadResult result;
                result.type = LoadResult::TypeStarted;
                cb(result);
            }

            pugi::xml_document doc;
            if (!doc.load_file(path.c_str()))
                throw std::exception("Error reading file!");

            auto dir = std::filesystem::path(path).parent_path();

            for (auto image : doc.child("dataset").child("images").children("image"))
            {
                if (!active)
                    break;

                auto name = image.attribute("file").as_string();
                auto in = dir / name;
                auto out = current / name;

                std::error_code ec;
                std::filesystem::create_directories(out.parent_path(), ec);

                if (std::filesystem::exists(out, ec) ||
                    std::filesystem::copy_file(in, out, std::filesystem::copy_options::skip_existing, ec))
                {
                    LoadResult result;
                    result.type = LoadResult::TypeImage;
                    result.image = std::make_shared<Image>();
                    result.image->name = name;
                    result.image->file = out.wstring();
                    fillBoxes(image, result.image->boxes);
                    if (save(result.image))
                    {
                        Lock l(mtx);
                        result.image->index = int(images.size());
                        images.push_back(result.image);
                    }
                    cb(result);
                }
            }

            {
                LoadResult result;
                result.type = LoadResult::TypeSuccess;
                cb(result);
            }
        }
        catch (const std::exception &e)
        {
            LoadResult result;
            result.type = LoadResult::TypeError;
            result.error = e.what();
            cb(result);
        }
        busy = false;
    };
    if (busy)
        return false;
    stop(true);
    active = true;
    {
        Lock l(mtx);
        images.clear();
    }
    worker = std::make_shared<std::thread>(fn);
    while (!busy)
        std::this_thread::sleep_for(std::chrono::microseconds(1));
    return true;
}
